/**
 * This file is part of CloudML [ http://cloudml.org ]
 *
 * Copyright (C) 2012 - SINTEF ICT
 * Contact: Franck Chauvel <franck.chauvel@sintef.no>
 *
 * Module: root
 *
 * CloudML is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * CloudML is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General
 * Public License along with CloudML. If not, see
 * <http://www.gnu.org/licenses/>.
 */
package org.cloudml.ui.shell;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.List;
import org.cloudml.facade.CloudML;
import org.cloudml.facade.commands.CloudMlCommand;
import org.cloudml.facade.events.Event;
import org.cloudml.ui.shell.configuration.commands.ShellCommand;
import org.cloudml.ui.shell.configuration.commands.ShellCommandHandler;
import org.cloudml.ui.shell.configuration.Configuration;
import org.cloudml.ui.shell.configuration.Loader;

import static org.cloudml.ui.shell.Message.*;
import static org.cloudml.ui.shell.Color.*;

/**
 * The CloudML Shell
 *
 * It allows the user to interact with the models and, in turn, with the
 * application deployed in the Cloud. This shell is based on the well-known
 * "command pattern": the input of the user is first parsed to get a Command
 * object, which can be stored or execute, or forwarded to the cloudML facade.
 *
 */
public class Shell implements ShellCommandHandler {

    private final CloudML proxy;
    private final Configuration configuration;
    private final List<ShellCommand> history;
    private final Terminal terminal;
    private final Mailbox mailbox;

    private boolean running;

    public Shell(CloudML proxy) {
        this.proxy = proxy;
        this.configuration = Loader.getInstance().getConfiguration();
        this.history = new ArrayList<ShellCommand>();
        this.terminal = new Terminal(configuration);  
        this.mailbox = new Mailbox(terminal); 
        proxy.register(mailbox.new EventHandler());
    }

    /**
     * Start the interaction with the user
     */
    public void start() {
        running = true;
        displayOpening();
        while (running) {
            execute(prompt());
        }
    }

    private void displayOpening() {
        terminal.print(format(configuration.getVersion()).eol().in(WHITE));
        terminal.print(format(configuration.getCopyright()).eol().in(WHITE));
        terminal.print(format(configuration.getLogo()).eol().in(CYAN));
        terminal.print(format(configuration.getDisclaimer()).eol().in(WHITE));
    }

    private String prompt() {
        if (mailbox.hasNewMessages()) {
            terminal.print(format("%d new message(s).", mailbox.size()).eol().in(GREEN));
        }
        return terminal.prompt();
    }

    /**
     * Parse and execute the command whose text is given as input
     *
     * @param text the text of the command to execute
     */
    public void execute(String text) {
        final ShellCommand command = ShellCommand.fromText(text);
        history.add(command);
        command.execute(this);
    }

    public void unknownCommand() {
        terminal.print(format("Error, command not supported yet!").in(RED));
    }

    public void exit() {
        running = false;
        terminal.print(format(configuration.getClosingMessage()).eol());
    }

    public void version() {
        terminal.print(format(configuration.getVersion()).eol());
    }

    public void history(int depth) {
        final int max = (depth == -1) ? history.size() : depth;
        for (int index = 1; index <= max; index++) {
            final int reversedIndex = history.size() - index;
            terminal.print(format(" %03d: %s", index, history.get(reversedIndex)).eol());
        }
    }

    public void help(String subject) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    public void dumpTo(int depth, String destination) {
        PrintStream script = null;
        try {
            script = new PrintStream(new File(destination));
            script.printf("#\n");
            script.printf("# Script generated by %s\n", configuration.getVersion());
            script.printf("# Please edit carefully\n");
            script.printf("#\n");

            final int max = (depth == -1) ? history.size() : depth;
            for (int index = 1; index <= max; index++) {
                final int reversedIndex = history.size() - index;
                final ShellCommand command = history.get(reversedIndex);
                if (command.isPersistent()) {
                    script.println(command);
                }
            }

        } catch (FileNotFoundException ex) {
            terminal.print(format("ERROR: unable to write in file '%s'", destination).eol().in(RED));

        } finally {
            script.close();
        }
    }

    public void replay(String pathToScript) {
        try {
            ShellCommand command = ShellCommand.fromFile(pathToScript);
            command.execute(this);

        } catch (FileNotFoundException ex) {
            terminal.print(format("ERROR: Unable to open the script at '%s'", pathToScript).eol().in(RED));

        } catch (IOException ex) {
            terminal.print(format("ERROR: unexpected I/O error while reading the script at '%s'", pathToScript).eol().in(RED));

        }
    }

    public void showMessages(int depth) {
        if (mailbox.hasNewMessages()) {
            final int max = (depth == -1) ? mailbox.size() : depth;
            terminal.print(format("Last messages:").eol());
            for (int index = 1; index <= max; index++) {
                final int reversedIndex = mailbox.size() - index;
                Event event = mailbox.contents().get(reversedIndex);
                terminal.print(format("  %03d: %s", index, event));
            }
        
        } else {
            terminal.print(format("No new message").eol());
        
        }
    }

    public void delegate(CloudMlCommand command, boolean runInBackground) {
        if (runInBackground) {
            proxy.fireAndForget(command);

        } else {
            mailbox.followUp(command);
            proxy.fireAndWait(command);
            mailbox.discard(command);
        }
    }

}
